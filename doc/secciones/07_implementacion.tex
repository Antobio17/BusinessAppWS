\chapter{Implementación}

La implementación del software se ha dividido en hitos. Estos, han sido definidos en Github
y cada uno de ellos contiene un grupo de \textit{issues} que se corresponden con las distintas
mejoras que se han ido incorporando al software a lo largo de su desarrollo.\\

\section{Tecnologías}

Podemos hacer la división en Front-End y Back-End con las tecnologías utilizadas en este aplicativo. 

Para la parte de Front-End se ha utilizado una tecnología algo reciente como es ReactJS de la compañia de Facebook, aunque al ser de software libre da la posibilidad a ser mantenida por la comunidad \cite{reactjs}. React es una biblioteca de JavaScript para construir interfaces de usuario. Está siendo actualmente altamente demandada en puestos de trabajo y es una nueva forma de llevar la programación de la lógica de negocio al Front-End. Con este framework tenemos la posibilidad de construir una página web dinámica y más optimizada para el usuario ya que React realiza una renderización por componentes y de DOM completo. 

Aunque no es requerido la sintaxis utilizada con React para la construcción del Front es JSX \cite{jsx}. Esta es una extensión de la sintaxis de JavaScript con la que podremos combinar código JavaScript con código HTML facilitando en gran medida la maquetación web y la construcción de componentes. Esto lo acompañaremos con las hojas de estilo en cascada (CSS) con las que daremos la apariencia deseada a los portales de los negocios.

En la parte de Back-End la tecnología utilizada ha sido PHP bajo el framework Symfony \cite{symfony}. El uso de un framework para el Back-End es casi necesario en estos momentos ya que facilita el montaje de un sistema MVC si está enfocado a ello. Además, el uso de capas para la gestión de los modelos y la base de datos aumenta la seguridad del sistema como por ejemplo, evitar la inyección de código ya que se sanitizan las entradas de datos. Otra de las ventajas que ofrece Symfony con  respecto a otros frameworks es la posibilidad de trabajar a más bajo nivel según deseemos y tener el control de cualquier proceso que implementemos en el proyecto. Sin olvidar tampoco la gran cantidad de Bundles (paquetes) desarrollados por la comunidad con funcionalidades muy interesantes como por ejemplo las sesiones con JSON Web Tokens.

\section{Librerias y Bundles}

Le sacaremos el máximo partido a las tecnologías haciendo uso de librerías y paquetes ya desarrollados con funcionalidades especificas. Vamos a destacar a continuación algunos de ellos.

\subsection{EasyAdminBundle}
Para la administración del sistema que implementaremos para el Back-End utilizaremos el Bundle EasyAdmin \cite{easyadmin} desarrollado para Symfony. Con este paquete podremos facilmente montar una vista de administración con permisos de usuarios para la gestión completa del sistema o gestión parcial de un único negocio. Esto es posible debido a que podemos montar un Modelo-Vista-Controllador en nuestro Back-End usando como modelo las entidades ya creadas para el aplicativo. Se podrá montar el CRUD de entidades invirtiendo muy poco tiempo y esfuerzo obteniendo una vista de estas ya maquetada.

\subsection{LexikJWTAuthenticationBundle}

Es obvio que en el sistema se deberá implementar una forma de autenticación de usuarios para poder acceder a los datos almacenados en el aplicativo. Se va a hacer uso por tanto de un Bundle desarrollado para Symfony como es LexikJWTAuthenticationBundle \cite{jwt}. Con éste tendremos la opción de manejar los inicios de sesión con JSON Web Tokens, los cuales se enviarán en las cabeceras de las peticiones de los clientes. De una forma sencilla tendremos la generación automática de estos JWT y comprobación con el usuario al cual corresponde.

\subsection{Axios} 

Realizaremos las llamadas al Back-End desde la parte del cliente con Axios \cite{axios}. Con esta librería podremos hacer llamadas asíncronas a los datos de nuestro sistema para eliminar los tiempos de carga completos de nuestras páginas webs. Esto es una parte importante del planteamiento de Front ya que el objetivo es hacer páginas dinámicas donde el usuario no se véa imposibilitado de interactuar con la web mientras espera la renderización de los productos de la tienda por ejemplo. Tambíen las llamadas asincronas mejorarán la velocidad de carga de estas ya que el DOM se irá cargando poco a poco de manera asincrona y no estará en su mayor parte bloqueado por la renderización completa. 

\subsection{Reporte de errores con Telegram} 

Todo sistema informático está expuesto a posibles errores no esperados por los desarrolladores. Detectar estos problemas a tiempo puede ser fundamental para el correcto funcionamiento del aplicativo o la defensa ante posibles patrones de ataques.
Para ello usaremos la API de TelegramBot \cite{telegrambot} con la que podremos enviarnos notificaciones desde servidor hasta un Bot de Télegram previamente configurado.

\section{Estructuración de código en Symfony}

En este proyecto Symfony vamos a tener los siguites tipos de archivos:

\begin{itemize}
    \item \textbf{Controller}: Los controladores serán los encargados de recibir las peticiones realizadas al servidor y sanitizar y validar los datos recibidos por el Request.
    \item \textbf{Entity}: Las entidades serán nuestro modelo de datos. Dentro de las entidades haremos uso de una herramienta denominada Annotations de Doctrine. Con esto definiremos nuestras tablas, atributos, relaciones y restricciones de la base de datos del Sistema.
    \item \textbf{Traits}: Los trait son trozos de código los cuales podremos inyectar en nuestros diferentes fichero según necesitemos. Principalmente los usaremos para definir propiedades comunes de entidades y así evitar la duplicidad de código en el proyecto.
    \item \textbf{Repository}: Los repositorios van a serán los encargados de recuperar las entidades de datos que tengamos almacenados. Con estos se podrán hacer consultas a la base de datos sin necesidad de realizar sentencias SQL directamente.
    \item \textbf{Service}: Los servicios serán la capa bajo los controladores. Estos se encargarán de realizar la lógica de negocio correspondiente a cada petición de los usuarios. Será la única capa con acceso a los repositorios de las entidades en la que se podrán persistir objetos ORM.
    \item \textbf{Interfaces}: Habrá interfaces por cada archivo del proyecto para tener una documentación completa de todas las funcionalidades implementadas.
    \item \textbf{Helpers}: Los helpers serán archivos con funcionalidades de ayuda como su nombre indica. Funcionalidad fuera de la lógica de negocio que nos puede facilitar cálculos repetitivos.
\end{itemize}

Con esta estructura podríamos decir que nuestro flujo sería el siguiente: el cliente realiza una petición al servidor. Esta llega a la ruta definida en uno de los controladores donde se tratarán los datos obtenidos del Request de manera que si no son válido reporte el correspondiente error al cliente. En el caso de ser válidos pasarán al respectivo Servicio (normalmente un controlador deberá tener asociado un servicio). En él se ejecutará la lógica de negocio definida donde se creará, recuperará, modificará o eliminará (CRUD) una entidad definida. Una vez procesado se devolverán los datos correspondientes al controlador (ya sean errores o los datos solicitados) y el controlador los devolverá al cliente con una respuesta en formato JSON.

Todo esto proceso registrará, en caso de producirse, errores en el aplicativo que serán notificados por Telegram como bien hemos comentado en un apartado anterior. Gracias a estas notificaciones y registro de errores el control para el Super-administrador del aplicativo será mucho mayor pudiendo solucionar errores en un menor periodo de tiempo.

\section{Despliegue}

